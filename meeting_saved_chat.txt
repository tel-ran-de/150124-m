10:25:26 From Starta Institute 36 to Everyone:
	public static int lSearch(int[] arr, int findEl) {
	        for (int i = 0; i < arr.length; i++) {
	            if (arr[i] == findEl) {
	                return i;
	            }
	        }
	        return -1;
	    }
10:25:38 From Starta Institute 36 to Everyone:
	Random rand = new Random();
	        int arrLen = 10;
	        int findEl = 0;
	        int[] arr = new int[arrLen];
	        for (int i = 0; i < arrLen; i++) {
	            arr[i] = rand.nextInt(21) - 10;
	        }
	        System.out.println("findEl = " + findEl);
	        System.out.println(Arrays.toString(arr));
	
	        int res = lSearch(arr, findEl);
	        if (res > -1) {
	            System.out.println(findEl + " has index " + res);
	        } else {
	            System.out.println(findEl + " not found in the array");
	        }
10:35:15 From Ramiz Alasgarov to Starta Institute 36(Direct Message):
	public static int lSearch(int[] arr, int findEl) {	        for (int i = arr.length; i > 0; i--) {	            if (arr[i] == findEl) {	                return i;	            }	        }	        return -1;	    }
10:37:12 From Ekaterina Beidel to Starta Institute 36(Direct Message):
	public static int lSearchReverse(int[] arr, int findEl) {	    for (int i = arr.length ; i > 0 ; i--) {	        if (arr[i] == findEl) {	            return i;	        }	    }	    return -1;	}
10:39:36 From Sergei Strukov to Starta Institute 36(Direct Message):
	public static int lSearch(int[] arr, int findEl) {	    for (int i = arr.length-1; i > 0 ; i--) {	        if (arr[i] == findEl) {	            return i;	        }	    }
10:43:35 From Esmira Abdullayeva to Starta Institute 36(Direct Message):
	public static int lSearch(int[] arr, int findEl) {
	      for (int i = 0; i < arr.length; i++) {
	            if (arr[arr.length - i - 1] == findEl) { 
	               return i;
	       }
	}
	return -1;
10:44:36 From Starta Institute 36 to Everyone:
	public static int lSearch(int[] arr, int findEl) {
	    for (int i = arr.length-1; i > 0 ; i--) {
	        if (arr[i] == findEl) {
	            return i;
	        }
	    }
10:45:39 From Starta Institute 36 to Everyone:
	public static int lSearch(int[] arr, int findEl) {
	    for (int i = arr.length-1; i > 0 ; i--) {
	        if (arr[i] == findEl) {
	            return i;
	        }
	    } return -1; }
10:47:07 From Maria Beljawski to Starta Institute 36(Direct Message):
	public static int rSearch(int[] arr, int findEl) {	        for (int i = ARR_LEN - 1; i >= 0; i--) {	            if (arr[i] == findEl) {	                return i;	            }	        }	        return -1;	    }	    }
10:50:33 From Ekaterina Beidel to Starta Institute 36(Direct Message):
	Не видно презентации
10:53:51 From Starta Institute 36 to Everyone:
	Двоичный (бинарный) поиск (также известен как метод деления пополам или дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. Используется в информатике, вычислительной математике и математическом программировании.
11:49:06 From Ekaterina Beidel to Everyone:
	public class BinarySearchRecursion {	    public static void main(String[] args) {	        Random random = new Random();	        int arrayLength = 10;	        int[] array = new int[arrayLength];	        for (int i = 0; i < arrayLength; i++) {	            array[i] = random.nextInt(11);	        }	        int findElement = 5;	        Arrays.sort(array);	        System.out.println(Arrays.toString(array));	        System.out.println(findElement + " has index " + recursiveBS(array, 0, arrayLength - 1, findElement));	    }
11:49:15 From Ekaterina Beidel to Everyone:
	public static int recursiveBS(int[] array, int firstIdx, int lastIdx, int findElement) {	    if (lastIdx >= firstIdx) {	        int midIdx = firstIdx + (lastIdx - firstIdx) / 2;	        if (array[midIdx] == findElement) {	            return midIdx;	        }	        if (array[midIdx] > findElement) {	            return recursiveBS(array, firstIdx, midIdx - 1, findElement);	        }	        return recursiveBS(array, midIdx + 1, lastIdx, findElement);	    }	    return -1;	}
12:07:13 From Starta Institute 36 to Everyone:
	public static void bubbleSort(int[] array) {
	        boolean isSorted = false;
	        int tmp;
	        while (!isSorted) {
	            isSorted = true;
	            for (int i = 0; i < array.length - 1; i++) {
	                if (array[i] > array[i + 1]) {
	                    tmp = array[i];
	                    array[i] = array[i + 1];
	                    array[i + 1] = tmp;
	                    isSorted = false;
	                }
	            }
	        }
	
	    }
12:07:25 From Starta Institute 36 to Everyone:
	int[] arr = {-1, 100, 9, 0, 5, 7};
	        System.out.println(Arrays.toString(arr));
	        bubbleSort(arr);
	        System.out.println(Arrays.toString(arr));
12:49:25 From Starta Institute 36 to Everyone:
	public static void quickSort(int[] arr, int first, int last) {
	        if (last <= first) {
	            return;
	        }
	        int pivot = partition(arr, first, last);
	        quickSort(arr, first, pivot - 1);
	        quickSort(arr, pivot + 1, last);
	    }
12:49:36 From Starta Institute 36 to Everyone:
	public static int partition(int[] arr, int first, int last) {
	        int pivot = last;
	
	        int counter = first;
	        for (int i = first; i < last; i++) {
	            if(arr[i] < arr[pivot]) {
	                int tmp = arr[counter];
	                arr[counter] = arr[i];
	                arr[i] = tmp;
	                counter++;
	            }
	        }
	        int tmp = arr[pivot];
	        arr[pivot] = arr[counter];
	        arr[counter] = tmp;
	
	        return counter;
	    }
12:49:49 From Starta Institute 36 to Everyone:
	int[] arr = {0, -10, 100, 2, 15};
	        System.out.println(Arrays.toString(arr));
	        quickSort(arr, 0, 4);
	        System.out.println(Arrays.toString(arr));
